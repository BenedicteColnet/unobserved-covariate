---
title: "Sensitivity analysis when transporting a causal effect"
author:
  - Bénédicte Colnet^[Inria, benedicte.colnet@inria.fr]
date: "March 2021"
output:
  pdf_document:
    toc: yes
  html_document:
    number_sections: no
    toc: yes
    toc_depth: 2
abstract: | 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)

# Set random generator seed for reproducible results
set.seed(123)

# Libraries
library(ggplot2) # plots
library(MASS) # simulation
library(tidyverse) # tidy data
library(matlib) # inverse of a matrix
library(stringi) # for function stri_paste
library(Rmisc) # summarySE

# Load methods from estimators.R 
source("./estimators.R")
```

# Preliminaries

Simulation of the small functions

```{r}
n = 100
m = 1000
x1 = runif(n, min = -1, max = 1)
x2 = runif(n, min = -1, max = 1)
rct <- data.frame("x1" = x1,
                           "x2" = x2,
                           "s" = rep(1, n))

x1 = runif(m, min = 0, max = 1)
x2 = runif(m, min = -1, max = 1)

obs <- data.frame("x1" = x1,
                  "x2" = x2,
                  "s" = rep(0, m))
toy_data_set <- rbind(rct, obs)

toy_data_set$cate <- ifelse(toy_data_set$x1 < 0 | toy_data_set$x2 <0, 0, toy_data_set$x1)

learned_cate_only_on_x1 <- lm(cate~x1, data = toy_data_set[toy_data_set$s == 1,])

mean(toy_data_set[toy_data_set$s == 1, "cate"])
mean(toy_data_set[toy_data_set$s == 0, "cate"])
mean(predict(learned_cate_only_on_x1, newdata = toy_data_set[toy_data_set$s == 0,]))
```

# Linear causal model

## Standard simulation

```{r}
generate_simulation <- function(bs = c(-0.4, 0, -0.3, -0.3, 0), beta = c(5, 5, 5, 5, 5), alpha = c(30, 30, -10, 0, 0), m = 10000, correlation = 0.8){

  # covariates definition
  p = length(bs)
  X_names <- paste("X", 1:p, sep = "")
  covariates_names <- c(X_names)
  Sigma = matrix(c(1, 0, 0, 0, correlation,
                   0, 1, 0, 0, 0,
                   0, 0, 1, 0, 0,
                   0, 0, 0, 1, 0,
                   correlation, 0, 0, 0, 1), nrow = 5, ncol = 5, byrow = TRUE)
   
  mu = rep(1, p)
    
  # generate source population for RCT
  source_data_for_RCT <- mvrnorm(n = m, mu = mu, Sigma = Sigma)  
  source_data_for_RCT <- as.data.frame(source_data_for_RCT)
  names(source_data_for_RCT) <- covariates_names
    
  # sample RCT
  etas <- as.vector(as.matrix(source_data_for_RCT[, paste("X", 1:p, sep = "")]) %*% bs)
  # P(S = 1 | X) 
  ps = 1 / (1 + exp(-etas))
  source_data_for_RCT$ps <- ps
  RCT_indicator <- rbinom(length(ps), 1, as.vector(ps))
  source_data_for_RCT$S <- RCT_indicator
    
  # random treatment assignment within the RCT
  source_data_for_RCT$A <- ifelse(source_data_for_RCT$S == 1, rbinom(nrow(source_data_for_RCT), 1, 0.5), NA)
      
  # keep only interesting variables
  source_data_for_RCT <- source_data_for_RCT[, c(covariates_names, "A", "S")]
      
  # drop other data
  RCT <- source_data_for_RCT[source_data_for_RCT$S == 1,]
  rm(source_data_for_RCT)
    
  # generate target population
  RWD <-  mvrnorm(n = m, mu = mu, Sigma = Sigma)
  RWD <- as.data.frame(RWD)
  names(RWD) <- covariates_names
    
  RWD$S <- rep(0, m)
  RWD$A <- rep(NA, m)
      
  # stack RCT and RWE
  DF <- rbind(RCT, RWD)
      
  # reset row number
  rownames(DF) <- 1:nrow(DF)
      
  # generate outcome
  error = rnorm(n = nrow(DF), mean = 0, sd = 0.2)
  DF$Y = beta[1]*DF$X1 + 
      beta[2]*DF$X2 + 
      beta[3]*DF$X3 + 
      beta[4]*DF$X4 + 
      beta[5]*DF$X5 +
      alpha[1]*(DF$A == 1)*DF$X1 + 
      alpha[2]*(DF$A == 1)*DF$X2 + 
      alpha[3]*(DF$A == 1)*DF$X3 + 
      alpha[4]*(DF$A == 1)*DF$X4 + 
      alpha[5]*(DF$A == 1)*DF$X5 +
      error   
  return(DF)  
}
```


```{r}
simulation <- generate_simulation()

ggplot(simulation ,aes(x = X1)) + 
    geom_histogram(data=subset(simulation, S == 1),fill = "red", alpha = 0.2, bins = 30) +
    geom_histogram(data=subset(simulation, S == 0),fill = "blue", alpha = 0.2, bins = 30) +
  theme_bw() +
  xlim(-4, 4) +
  ylim(-2, 1200)

ggplot(simulation, aes(x = X5)) + 
    geom_histogram(data=subset(simulation, S == 1),fill = "red", alpha = 0.2, bins = 30) +
    geom_histogram(data=subset(simulation, S == 0),fill = "blue", alpha = 0.2, bins = 30) +
  theme_bw() +
  xlim(-4, 4) +
  ylim(-2, 1200)
```


## Bias and missing data pattern

```{r}
# recall parameters for the simulation
p = 5
Sigma = matrix(c(1, 0, 0, 0, 0.8,
                   0, 1, 0, 0, 0,
                   0, 0, 1, 0, 0,
                   0, 0, 0, 1, 0,
                   0.8, 0, 0, 0, 1), nrow = 5, ncol = 5, byrow = TRUE)
alpha = c(30, 30, -10, 0, 0)

# #estimate RCT shift - used only once
# simulation <- generate_simulation(m = 10000000)
# RCT <- simulation[simulation$S == 1,]
# expected_values_RCT <- c("X1" = mean(RCT$X1),
#                      "X2" = 1,
#                      "X3" = mean(RCT$X3),
#                      "X4" = mean(RCT$X4),
#                      "X5" = mean(RCT$X5))
# TAU1 <- compute_mean_diff_RCT(simulation)

expected_values_RCT <- c("X1" = 0.7311443,
                     "X2" = 1,
                     "X3" = 0.7978450,
                     "X4" = 0.7985870,
                     "X5" = 0.7847962)
expected_values_RWE <- rep(1, p)
TAU1 <- 44
```




```{r}
# vectors to store our results
theoretical_bias <- c()
missing <- c()

# loop over various missing covariate patterns
for (nb_mis in 3:p-2){
  patterns <- combn(1:p, nb_mis)
  for(index in 1:dim(patterns)[2]){
    
    mis = patterns[,index]
    
    # create variance-covariance matrix
    obs <- setdiff(1:p, mis)
    Sigma_mis_obs <- Sigma[mis, obs]
    Sigma_obs_obs <- Sigma[obs, obs]
     
    # compute bias according to lemma
    bias <- alpha[mis] %*% ( (expected_values_RWE[mis] - expected_values_RCT[mis]) -
                                      Sigma_mis_obs%*% inv(Sigma_obs_obs)%*% (expected_values_RWE[obs] - expected_values_RCT[obs]))
    # 
    # # store results
    theoretical_bias <- c(theoretical_bias, bias)
    missing <- c(missing, stri_paste(paste0(rep("X", nb_mis), mis), collapse = ", "))
  }
}

theoretical_bias_result  <- data.frame("Bias" = theoretical_bias,
                                       "without" = missing)
```


```{r, echo = FALSE, message = FALSE}
TRUE_ATE <- 50
repetitions = 100
estimate = c()
method = c()
without = c()
variables = c("X1", "X2", "X3", "X4", "X5")
columns = names(simulation)
N <- c()


for(sample_size in c(10000)){ 
    for (i in 1:repetitions){
      
    # generate a simulation
    simulation <- generate_simulation(m = sample_size, correlation = 0)
    
    # loop over various missing covariate patterns
    for (nb_mis in c(1,2,3)){ #3:p-2
      patterns <- combn(1:p, nb_mis)
      for(index in 1:dim(patterns)[2]){
        mis = patterns[,index]
        obs <- setdiff(1:p, mis)
        columns_to_keep <- paste(rep("X",length(obs)), obs, sep = "")
        columns_to_keep <- c(columns_to_keep, "S", "A", "Y")
  
        estimate <- c(estimate, compute_mean_diff_RCT(simulation),
                      compute_ipsw(simulation[, columns_to_keep], normalized = TRUE),
                       compute_gformula(simulation[, columns_to_keep]),
                      compute_aipsw(simulation[, columns_to_keep], normalized = TRUE)) 
                      
       method <- c(method, "Tau_DM", "IPSW", "G-formula", "AIPSW")
       missing <- stri_paste(paste0(rep("X", nb_mis), mis), collapse = ", ")
       without <- c(without, missing, missing, missing, missing)
      }
    }
       # with all variables (control)
       estimate <- c(estimate,  compute_mean_diff_RCT(simulation),
                      compute_ipsw(simulation, normalized = TRUE),
                       compute_gformula(simulation),
                     compute_aipsw(simulation, normalized = TRUE))
                      
       method <- c(method, "Tau_DM", "IPSW", "G-formula", "AIPSW")
       without <- c(without, "none", "none", "none", "none")
       N <- c(N, sample_size, sample_size, sample_size, sample_size)
    }
}

results_simple_simulations <- data.frame("Estimate" = estimate,
                                         "Method" = method,
                                         "without" = without,
                                         "N" = N)
```


```{r}
empirical_bias <- results_simple_simulations[results_simple_simulations$without != "none" & results_simple_simulations$Method == "G-formula",] %>%
  group_by(without, N) %>%
  summarise_at(vars(Estimate), list(mean = mean, sd = sd))

empirical_bias$se <- empirical_bias$sd / 100

results_bias <- merge(theoretical_bias_result, empirical_bias, by = "without")
results_bias$mean <- TRUE_ATE - results_bias$mean 
```


```{r}
ggplot(results_bias, aes(x = without, y = mean)) +
  geom_point(alpha = 0.4) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width=.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ylab("Bias") +
  xlab("Missing covariate(s)") +
  geom_point(aes(x = without, y = Bias), shape = 13) +
  ggsave("./bias_bis.pdf")
```



```{r, echo = FALSE, message = FALSE}
ATE_RCT <- mean(results_simple_simulations[results_simple_simulations$Method == "Tau_DM", "Estimate"])

ggplot(results_simple_simulations[results_simple_simulations$Method != "Tau_DM" & results_simple_simulations$Method != "AIPSW" & results_simple_simulations$without %in% c("none", "X2, X4", "X1", "X3", "X1, X3", "X2", "X4"),], aes(x = Method, y = Estimate, fill = Method)) +
  geom_boxplot() +
  facet_grid(~without) +
  theme_bw() + 
  geom_hline(aes(yintercept = TRUE_ATE, linetype = "Target population's ATE"), color = "red") +
  geom_hline(aes(yintercept = ATE_RCT, linetype = "RCT's ATE"), color = "darkblue") +
  theme(text = element_text(size=12), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  xlab("") +
  ggtitle("Missing covariate(s): ") +
  xlab("") +
  ylab("ATE")  +
    theme(legend.title = element_blank(), 
          legend.position="bottom", legend.box = "horizontal") +  # no title in legend
  scale_fill_brewer(palette = "Set2") +
  ggsave("./simple-simulation.pdf")
```

## Impact of coefficients

```{r}
correlations_X1_X5 <- c(0.05, 0.5, 0.95)
coefficients_bias_results <- data.frame("correlations_X1_X5" = c(),
                                        "beta_5" = c(),
                                        "delta_5"= c(),
                                        "bias" = c())
for (cor in correlations_X1_X5){
  for (i in 1:100){
    simulation <- generate_simulation(correlation = cor)
    reg_lin_treat_wo_X1 <- lm(Y~X2+X3+X4+X5, data = simulation[simulation$S == 1 & simulation$A == 1,])
    reg_lin_not_treat_wo_X1 <- lm(Y~X2+X3+X4+X5, data = simulation[simulation$S == 1 & simulation$A == 0,])
    beta_5 = reg_lin_not_treat_wo_X1$coefficients["X5"]
    delta_5 = reg_lin_treat_wo_X1$coefficients["X5"] - beta_5
    
    bias = TRUE_ATE - compute_gformula(simulation[, c("X2", "X3", "X4", "X5", "S", "A", "Y")])
    
    new_result = data.frame("correlations_X1_X5" = cor, "beta_5" = beta_5, "delta_5" = delta_5, "bias" = bias)
    
    coefficients_bias_results <- rbind(coefficients_bias_results, new_result)
  }
}

```

```{r}
library(plyr)

ddply(coefficients_bias_results, .(correlations_X1_X5), summarize,  Beta_5 = mean(beta_5), Delta_5 = mean(delta_5), Bias = mean(bias))
```


# Sensitivity analysis

```{r}
variables = c("X1", "X2", "X3", "X4", "X5")
columns_to_keep = c("X2", "X3", "X4", "X5", "S", "A", "Y")
correlations_X1_X5 = 0.8
```

## Totally missing covariate

```{r}
# initialization parameters for the heat map
shifts <- seq(-0.3, 0.3, by = 0.05)
deltas <- seq(-35, 35, by = 1) 

# generate a data set - here 0 correlation because independence hypothesis
simulation <- generate_simulation(correlation = 0)
n = nrow(simulation[simulation$S == 1,])
m = nrow(simulation[simulation$S == 0,])
tau_hat_dm <- compute_mean_diff_RCT(simulation)
mu_1 = lm(Y ~., data = simulation[simulation$S == 1 & simulation$A == 1, !names(simulation) %in% c("S", "A")])
mu_0 = lm(Y ~., data = simulation[simulation$S == 1 & simulation$A == 0, !names(simulation) %in% c("S", "A")])
hat_deltas = mu_1$coefficients - mu_0$coefficients
tau_hat_gformula <- compute_gformula(simulation)

# generate grid for heatmap
heatmap_data <- as.data.frame(expand.grid(shifts, deltas))
names(heatmap_data) <- c("shift", "delta")
heatmap_data$bias <- heatmap_data$shift*heatmap_data$delta


heatmap_data$R2 <- rep(NA, nrow(heatmap_data))
for(shift_sens in shifts){
  U_rct <- rnorm(n = n, mean = 1-shift_sens, sd =1)
  U_rwe <- rnorm(n = m, mean = 1, sd =1)
  simulation$U <- c(U_rct, U_rwe)
  for(delta_sens in deltas){
    # noise = rnorm(n = n+m, mean = 0, sd = 1)
    # simulation$CATE_with_obs <- predict(mu_1, newdata = simulation) - predict(mu_0, newdata = simulation) + noise
    # simulation$trueCATE_if_delta <- simulation$CATE_with_obs + delta_sens*simulation$U
    # 
    # R2 <- delta_sens*delta_sens*var(simulation[simulation$S == 0, "U"]) /var(simulation[simulation$S == 0, "CATE_with_obs"])
    var_u = 1
    R2 <- delta_sens*delta_sens*var_u/var(predict.lm(mu_1, newdata = simulation[simulation$S == 0,]) - predict.lm(mu_0, newdata = simulation[simulation$S == 0,]))
    
    heatmap_data$R2 <- ifelse(heatmap_data$shift == shift_sens & heatmap_data$delta == delta_sens, R2, heatmap_data$R2)
  }
}


# sensitivity parameters of others covariates
other_covariates <- data.frame("variable" = c(),
                               "bias" = c(),
                               "shift" = c(),
                               "delta" = c(),
                               "R2" = c())

for (variable in variables){

  shift_for_this_variable <- mean(simulation[simulation$S == 0, variable]) - mean(simulation[simulation$S == 1, variable])

  delta_for_this_variable <- hat_deltas[variable]

  emprirical_bias_obtained = TRUE_ATE - compute_gformula(simulation[, setdiff(names(simulation), variable)])

  # for R2, the idea is to match previous computed ones using delta and shift
  # ideally: change this function for a data table
  closest_shift <- heatmap_data$shift[which.min(abs(heatmap_data$shift-shift_for_this_variable))]
  closest_delta <- heatmap_data$delta[which.min(abs(heatmap_data$delta-delta_for_this_variable))]
  R2 = heatmap_data[heatmap_data$shift == closest_shift &
                      heatmap_data$delta == closest_delta, "R2"]

  # update table
  other_covariates <- rbind(other_covariates, data.frame("variable" = variable,
                                                "bias" = emprirical_bias_obtained,
                                        "shift" = shift_for_this_variable,
                                        "delta" = delta_for_this_variable,
                            "R2" = R2))
}
```

```{r}
library(ggrepel)
ggplot(heatmap_data, aes(x = shift, y = delta, z = bias)) + 
  # stat_contour() +
  theme_classic() + 
  geom_contour_filled() +
  stat_contour(breaks = tau_hat_gformula - tau_hat_dm) +
  geom_point(data = other_covariates,
             aes(x = shift,
                 y = delta, label = variable),
                 shape = 3) +
  geom_label_repel(data = other_covariates, aes(x = shift, y = delta, label = variable)) +
  scale_fill_distiller(super = metR::ScaleDiscretised, palette = "Spectral") +
  xlab("Shift") +
  ylab("delta") +
  ggtitle("Sensivity analysis - totally missing covariate") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ggsave("./totally-missing-linear.pdf")
  
```

## Missing data in observational data set

Nguyen method application.

```{r}
simulation <- generate_simulation(correlation = correlations_X1_X5)
sensitivity_parameter_nguyen = seq(0.8, 1.2, by = 0.01) # represents the guess on E[U] in target pop.
margin_on_parameter = 0.05
results_nguyen_obs_data <- data.frame("sensitivity_parameter" = c(),
                                      "Target_ATE" = c(),
                                      "Margin" = c())

for (sensitivity_parameter in sensitivity_parameter_nguyen){
  
  mu_1 <- lm(Y~X1+X2+X3+X4+X5, data = simulation[simulation$S == 1 & simulation$A == 1,])
  mu_0 <- lm(Y~X1+X2+X3+X4+X5, data = simulation[simulation$S == 1 & simulation$A == 0,])
  deltas = (mu_1$coefficients - mu_0$coefficients)
  
  # replace the predicted values with outcome regression
  simulation[simulation$S == 0, "Y"] <- predict(mu_1, newdata = simulation[simulation$S == 0,]) - predict(mu_0, newdata = simulation[simulation$S == 0,]) 
  
  ate <- deltas[variables_to_keep] %*%  as.matrix(colMeans(simulation[simulation$S == 0, variables_to_keep]))  +  deltas[1]
  ate_min  = ate + deltas[missing_covariate] * (sensitivity_parameter - margin_on_parameter)
  ate_max  = ate + deltas[missing_covariate] * (sensitivity_parameter + margin_on_parameter) 
  
  new_result <- data.frame("sensitivity_parameter" = sensitivity_parameter, "Target_ATE" = (ate_max + ate_min)/2, "upper" = ate_max, "lower" = ate_min)
  
  results_nguyen_obs_data <- rbind(results_nguyen_obs_data, new_result)
}
```


```{r}
ggplot(results_nguyen_obs_data, aes(x = sensitivity_parameter, y = Target_ATE)) +
  geom_line() +
  theme_bw() +
  geom_hline(aes(yintercept = TRUE_ATE, linetype = "Target population's ATE"), color = "red") +
  geom_hline(aes(yintercept = ATE_RCT, linetype = "RCT's ATE"), color = "darkblue") +
  #geom_ribbon(aes(ymin = results_nguyen_obs_data$lower, ymax = results_nguyen_obs_data$upper), linetype=2, alpha=0.1) +
  ylab("ATE") +
  xlab("Sensitivity parameter ~ E[U]") +
    theme(legend.title = element_blank(), 
          legend.position="bottom", legend.box = "horizontal") +
  ggtitle("Sensivity analysis when missing covariate in observational study") +
  ggsave("./Nguyen_method.pdf")
```

## Missing data in RCT

```{r}
compute_bias_from_shift_and_delta <- function(shift, delta, data, sigma, missing_covariate_position){
  
  mis = missing_covariate_position
  obs = setdiff(1:5, missing_covariate_position)
  
  # compute necessary information from observational data (complete data set)
  sigma_mis_obs = sigma[mis, obs]
  sigma_obs_obs = sigma[obs, obs]
  delta_obs <- expected_values_RWE[obs] - expected_values_RCT[obs]
  
  # bias formula according to paper
  bias = delta*(shift - sigma_mis_obs %*% inv(sigma_obs_obs) %*% delta_obs)
  return(bias)
}

compute_R2_from_delta <- function(delta, coefficients, sigma, missing_covariate_position){
  
  missing_variable = paste0("X", missing_covariate_position)
  
  variables = setdiff(names(data), c(missing_variable, "S", "A", "Y"))

  # compute partial coefficients here
  
  cov_term = 0
  cov_u_term = 0
  delta_x_term = 0
  for (l in 1:4){
    cov_u_term = cov_u_term +2*coefficients[l]*coefficients[missing_covariate_position]*sigma[missing_covariate_position,l]
    start = l+1
    if (l!= missing_covariate_position){
      delta_x_term = delta_x_term + sigma[l,l]*coefficients[l]^2
      for (k in start:5){
        if (k!=missing_covariate_position){
          cov_term = cov_term + 2*coefficients[l]*coefficients[k]*sigma[l,k]
        }
      }
    }
  }
 
  R2 <- (-delta*delta*sigma[missing_covariate_position, missing_covariate_position]-cov_u_term) / (coefficients*coefficients%*%diag(sigma) + cov_term)
  
  return(R2)
  
}

# initialization parameters for the heat map
shifts <- seq(-0.5, 0.5, by = 0.05)
deltas <- seq(-35, 35, by = 1) 

final_data <- data.frame("shift" = c(), 
                         "delta" = c(),
                         "bias" = c(),
                         "true_bias" = c(),
                         "true_shift" = c(),
                         "true_delta" = c(),
                         "missing_variable" = c())


# generate a data set
simulation <- generate_simulation(correlation = correlations_X1_X5)
empirical_sigma = cor(simulation[simulation$S == 0 , c("X1", "X2", "X3", "X4", "X5")])

# browse all the variables
for (missing_variable_number in 1:5){
  
  missing_variable = paste0("X", missing_variable_number)
  
  heatmap_data <- as.data.frame(expand.grid(shifts, deltas))
  names(heatmap_data) <- c("shift", "delta")
  
  # compute bias
  heatmap_data$bias <- compute_bias_from_shift_and_delta(shift = heatmap_data$shift, delta = heatmap_data$delta, data = simulation, sigma = empirical_sigma, missing_covariate_position = missing_variable_number)
  
  mu_1 <- lm(Y ~., data = simulation[simulation$S == 1 & simulation$A == 1, !names(simulation) %in% c("S", "A", missing_variable)])
  mu_0 <- lm(Y ~., data = simulation[simulation$S == 1 & simulation$A == 0, !names(simulation) %in% c("S", "A", missing_variable)])
  
  deltas_hat <- mu_1$coefficients - mu_0$coefficients
    
  mu_1_predict <- predict.lm(mu_1, newdata = simulation[simulation$S == 0, !names(simulation) %in% c("S", "A")])
  mu_0_predict <- predict.lm(mu_0, newdata = simulation[simulation$S == 0, !names(simulation) %in% c("S", "A")])
    
  tau_hat_gformula <- mean(mu_1_predict) - mean(mu_0_predict)
  
  heatmap_data$true_bias <- TRUE_ATE - tau_hat_gformula
  
  heatmap_data$true_shift <- mean(simulation[simulation$S == 0 ,missing_variable]) -  mean(simulation[simulation$S == 1 ,missing_variable])
  
  heatmap_data$true_delta <- alpha[missing_variable_number]
    
  heatmap_data$missing_variable <- rep(missing_variable, nrow(heatmap_data))
  
  heatmap_data$R2 <- compute_R2_from_delta(heatmap_data$delta, coefficients = deltas_hat, sigma = empirical_sigma, missing_variable_number)
  
  final_data <- rbind(final_data, heatmap_data)
}

```

```{r}
library(metR)
ggplot(final_data[final_data$missing_variable != "X5", ], aes(x = shift, y = delta, z = bias)) + 
  #stat_contour() +
  theme_classic() + 
  geom_contour_filled() +
  stat_contour(breaks = 5) + 
  #geom_hline(yintercept=30) + 
  #geom_vline(xintercept = 0.2) +
  facet_grid(~missing_variable) +
  geom_point(data = final_data[final_data$missing_variable != "X5", ],
             aes(x = true_shift,
                 y = true_delta),
                 shape = 3) +
  scale_fill_distiller(super = metR::ScaleDiscretised, palette = "Spectral") +
  xlab("Shift") +
  ylab("Delta") +
  ggtitle("Sensivity analysis - missing covariate in RCT") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  ggsave("./sensitivity_missing_rct.pdf")
```

## Proxy 

Now we suppose we do not have X1, but rather X6 which is generated from X1.

```{r}
noises <- c(0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5)
results_proxy <- data.frame("estimate" = c(),
                            "noise" = c(), 
                            "empirical_bias" = c(),
                            "theoretical_bias" = c(),
                            "estimate.OV" = c())

for (noise in noises){
  for (i in 1:100){
    
    # create proxy
    simulation <- generate_simulation(m = 10000, correlation = 0)
    error <- rnorm(nrow(simulation), mean = 0, sd = noise)
    simulation$X6 <- simulation$X1 + error
    
    estimate <- compute_gformula(simulation[,c("X2", "X3", "X4", "X5", "X6", "A", "S", "Y")])
    estimate_with_omitted_variable <- compute_gformula(simulation[,c("X2", "X3", "X4", "X5", "A", "S", "Y")])
    empirical_bias <- TRUE_ATE - estimate
    correlation <- cor(simulation$X1, simulation$X6, method="pearson")
    shift = mean(simulation[simulation$S == 0, "X6"]) - mean(simulation[simulation$S == 1, "X6"])
    delta_prox_hat <- lm(Y~., data = simulation[simulation$S == 1 & simulation$A == 1, c("X2", "X3", "X4", "X5", "X6", "A", "S", "Y")])$coefficients["X6"] - lm(Y~., data = simulation[simulation$S == 1 & simulation$A == 0, c("X2", "X3", "X4", "X5", "X6", "A", "S", "Y")])$coefficients["X6"]
    theory <- 30*(1 - expected_values_RCT["X1"])*(1 -  1/(1+ noise*noise)) # correct one
    # theory <- delta_prox_hat*shift*noise*noise
    # theory <- 30*shift*(noise*noise-1)/(noise*noise)
    new_result <- data.frame("estimate" = estimate, "noise" = noise, "empirical_bias" = empirical_bias, "theoretical_bias" = theory, "estimate.OV" = estimate_with_omitted_variable)
    results_proxy <- rbind(results_proxy, new_result)
  }
}
```


```{r}
theoretical_results <- results_proxy %>%
  group_by(noise) %>%
  dplyr::summarise(avg_theoretical_bias = mean(theoretical_bias),
            uci_theoretical_bias = CI(theoretical_bias)[1],
            lci_theoretical_bias = CI(theoretical_bias)[3])

ggplot(results_proxy, aes(x = as.factor(noise), y = empirical_bias)) +
  #geom_jitter(width = 0.2) +
  geom_boxplot() +
  geom_point(data=theoretical_results, aes(x = as.factor(noise), y = lci_theoretical_bias), size=4, color = "red") +
  geom_hline(yintercept = TRUE_ATE - mean(results_simple_simulations[results_simple_simulations$without == "X1, X5" & results_simple_simulations$Method == "G-formula", "Estimate"])) +
  theme_bw() +
  ggsave("./simulation-linear-proxy.pdf")

```


# Binary outcome

```{r}
generate_simulation_logit <- function(bs = c(-0.3, 0, -0.3, -0.3, 0), beta = c(-1, 1, -1, 2, 0), alpha = c(2, 1, 1, 0, 0), m = 10000, p =5){
    
  # fix covariate name, p is also hard coded for now
  X_names <- paste("X", 1:p, sep = "")
  covariates_names <- c(X_names)
    
  # properties of the covariates
  Sigma = matrix(c(1, 0, 0, 0, 0, 
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1), nrow = p, ncol = p, byrow = TRUE)
   
  mu = rep(1, p)
    
  # generate source population for RCT
  source_data_for_RCT <- mvrnorm(n = m, mu = mu, Sigma = Sigma)  
  source_data_for_RCT <- as.data.frame(source_data_for_RCT)
  names(source_data_for_RCT) <- covariates_names
    
  # sample RCT
  etas <- as.vector(as.matrix(source_data_for_RCT[, paste("X", 1:p, sep = "")]) %*% bs)
   
  # P(S = 1 | X) corresponds to ps 
  ps = 1 / (1 + exp(-etas))
    
  source_data_for_RCT$ps <- ps
  RCT_indicator <- rbinom(length(ps), 1, as.vector(ps))
  source_data_for_RCT$S <- RCT_indicator
    
    
  # random treatment assignment within the RCT
  source_data_for_RCT$A <- ifelse(source_data_for_RCT$S == 1, rbinom(nrow(source_data_for_RCT), 1, 0.5), NA)
      
  # keep only interesting variables
  source_data_for_RCT <- source_data_for_RCT[, c(covariates_names, "A", "S")]
      
  ## drop other data
  RCT <- source_data_for_RCT[source_data_for_RCT$S == 1,]
  rm(source_data_for_RCT)

  # generate target population
  RWD <-  mvrnorm(n = m, mu = mu, Sigma = Sigma)
  RWD <- as.data.frame(RWD)
  names(RWD) <- covariates_names

  RWD$S <- rep(0, m)
  RWD$A <- rep(0, m) # to avoid NA generation

  # stack RCT and RWE
  DF <- rbind(RCT, RWD)

  # reset row number
  rownames(DF) <- 1:nrow(DF)

  # generate outcome
  etas <- (beta[1]*DF$X1 +
      beta[2]*DF$X2 +
      beta[3]*DF$X3 +
      beta[4]*DF$X4 +
      beta[5]*DF$X4 +
      alpha[1]*(DF$A == 1)*DF$X1 +
      alpha[2]*(DF$A == 1)*DF$X2 +
      alpha[3]*(DF$A == 1)*DF$X3 +
      alpha[4]*(DF$A == 1)*DF$X4 +
      alpha[5]*(DF$A == 1)*DF$X5) - 1
  
  py = 1 / (1 + exp(-etas))

  # transform to binary
  DF$Y <- rbinom(length(py), 1, py)
  
  # delete A and Y in RWE
  DF[DF$S == 0, c("Y", "A")] <- NA

  return(DF)
}

simulation <- generate_simulation_logit()
```



```{r}
repetitions = 50
estimate = c()
method = c()
without = c()
variables = c("X1", "X2", "X3", "X4", "X5")
columns = names(simulation)

for (i in 1:repetitions){
  
  # generate a simulation
  simulation <- generate_simulation_logit()
  
  # run on the data set with missing covariate
  for (column in variables){
    columns_to_keep <- setdiff(union(columns, column), intersect(columns, column))
    estimate <- c(estimate,
                  compute_ipsw(simulation[, columns_to_keep], normalized = TRUE),
                   compute_gformula(simulation[, columns_to_keep], continuous_Y = FALSE)) 
                  
   method <- c(method, "IPSW", "G-formula")
   without <- c(without, column, column)
  }
   
   # with all variables (control)
   estimate <- c(estimate,
                  compute_ipsw(simulation, normalized = TRUE),
                   compute_gformula(simulation, continuous_Y = FALSE))
                  
   method <- c(method, "IPSW", "G-formula")
   without <- c(without, "none", "none")
   
  
}

results_logit <- data.frame("Estimate" = estimate,
                                         "Method" = method,
                                         "without" = without)
```

```{r}
ggplot(results_logit, aes(x = Method, y = Estimate, fill = Method)) +
  geom_boxplot() +
  facet_grid(~without) +
  theme_bw() + 
  geom_hline(yintercept = ATE_RCT_binary, color = "darkblue", linetype = "dashed") +
  geom_hline(yintercept = ATE_target_binary, color = "purple", linetype = "dashed") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  xlab("") +
  ggtitle("Missing covariate(s) in both data set - Binary")  +
    theme(legend.title = element_blank(), 
          legend.position="bottom", legend.box = "horizontal") +  # no title in legend
  scale_fill_brewer(palette = "Set2") +
  ggsave("./simple-simulation-logit.pdf")
```


# Imputation

```{r}
repetitions = 100
correlation_coefficients <- c(0.1, 0.25, 0.5, 0.75, 0.9)

results_when_imputing <- data.frame("correlation" = c(),
                      "with.imputed.X1.missing.in.RCT" = c(),
                      "with.imputed.X1.missing.in.obs" = c(),
                      "with.imputed.X1.missing.in.RCT.IPSW" = c(),
                      "with.imputed.X1.missing.in.obs.IPSW" = c(),
                      "totally.missing.covariate" = c())

restricted_set_variables <- c("X2", "X3", "X4", "X5", "S", "A", "Y")

for (coeff in correlation_coefficients){
  for (rep in 1:repetitions){
    
    # generate simulation
    simulation <- generate_simulation(correlation = coeff) 
   
   # create models
    lm.missing.RCT <- lm(X1 ~ ., data = simulation[simulation$S == 0, variables])
    lm.missing.obs <- lm(X1 ~ ., data = simulation[simulation$S == 1, variables])
    
    # impute
    simulation$replacement.RCT <- c(predict.lm(lm.missing.RCT, newdata = simulation[simulation$S == 1,]), simulation[simulation$S == 0, "X1"])
    simulation$replacement.obs <- c(simulation[simulation$S == 1, "X1"], predict.lm(lm.missing.obs, newdata = simulation[simulation$S == 0,]))
    
    results_when_imputing <- rbind(results_when_imputing, data.frame("correlation" = coeff,
                      "with.imputed.X1.missing.in.RCT.gformula" = compute_gformula(simulation[,c(restricted_set_variables, "replacement.RCT")]),
                      "with.imputed.X1.missing.in.obs.gformula" = compute_gformula(simulation[,c(restricted_set_variables, "replacement.obs")]),
                      "with.imputed.X1.missing.in.RCT.IPSW" = compute_ipsw(simulation[,c(restricted_set_variables, "replacement.RCT")], normalized = TRUE),
                      "with.imputed.X1.missing.in.obs.IPSW" = c(compute_ipsw(simulation[,c(restricted_set_variables, "replacement.obs")], normalized = TRUE)),
                      "totally.missing.covariate" = c(compute_gformula(simulation[,restricted_set_variables]))))
  
  }  
}


```



```{r}
results_when_imputing %>% 
  pivot_longer(cols = c("with.imputed.X1.missing.in.RCT.gformula", "with.imputed.X1.missing.in.obs.gformula", "totally.missing.covariate", "with.imputed.X1.missing.in.RCT.IPSW", "with.imputed.X1.missing.in.obs.IPSW"), names_to = "method", values_to = "estimates") %>%
  ggplot(aes(x = method, y = estimates, fill = method)) +
  geom_boxplot() +
  facet_grid(~correlation) +
  theme_classic() +
  theme(axis.text.x=element_text(angle=45, hjust=1)) +
  geom_hline(yintercept = TRUE_ATE, color = "red") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  ggsave("./linear_imputation_variance_effect.pdf")
```



# Reproducing Kallus simulation
```{r}
library(Rlab) # rbern
n = 3000

# Generate RCT
## Generate the treatment vector, randomized
A = rbern(n, 0.5)

X = runif(n, min = -1, max = 1)
U = rnorm(n, mean = 0, sd = 1)

## Function to generate the y 
generate_y <- function(x, u, a){
  error = rnorm(length(x), mean = 0, sd = 1)
  return(1 + a + x + 2*a*x + 0.5*x*x + 0.75*a*x*x + u + 0.5*error)
}

Y = generate_y(X, U, A)

RCT = data.frame("X" = X,
                 "U" = U,
                 "A" = A,
                 "Y" = Y)

# Generate Obs
## First sample treatment
A = rbern(3*n, 0.5)

## Then sample X and U
mus = c(0, 0)
covariance_A_1 = 0.5
covariance_A_0 = -0.5
Sigma_A_1 =matrix(c(1, covariance_A_1,
                   covariance_A_1, 1), nrow = 2, ncol = 2)
Sigma_A_0 =matrix(c(1, covariance_A_0,
                   covariance_A_0, 1), nrow = 2, ncol = 2)

# re initialize vectors
X = c()
U = c()
Y = c()

for (a in A){
  if (a == 1){
    x_and_u <- mvrnorm(n = 1, mus, Sigma = Sigma_A_1)
  } else {
    x_and_u <- mvrnorm(n = 1, mus, Sigma = Sigma_A_0)
  }
  X <- c(X, x_and_u[1])
  U <- c(U, x_and_u[2])
  Y <- c(Y, generate_y(x_and_u[1], x_and_u[2], a))
}

RWD <- data.frame("X" = X,
                  "U" = U,
                  "A" = A,
                  "Y" = Y)

Kallus_Shalit_simulation <- rbind(RCT, RWD)

ggplot(RCT, aes(x = X, y = U, color = as.factor(A))) +
  geom_point() +
  theme_bw() +
  xlim(-4, 4) +
  ylim(-4, 4) +
  facet_grid(~as.factor(A))

ggplot(RWD, aes(x = X, y = U, color = as.factor(A))) +
  geom_point() +
  theme_bw() +
  xlim(-4, 4) +
  ylim(-4, 4) +
  facet_grid(~as.factor(A))
```


```{r}

```

